<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nacos在Windows部署配置</title>
    <link href="/2024/09/03/%E5%8D%9A%E5%AE%A2-2024-09-03-20-32-06/"/>
    <url>/2024/09/03/%E5%8D%9A%E5%AE%A2-2024-09-03-20-32-06/</url>
    
    <content type="html"><![CDATA[<p>1、下载<br>下载地址：<a href="https://github.com/alibaba/nacos/releases%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%90%8E%E7%BC%80%E5%90%8D%E4%B8%BA.zip%E7%9A%84%E6%96%87%E4%BB%B6">https://github.com/alibaba/nacos/releases，下载后缀名为.zip的文件</a></p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/image-20240903212341404.png" alt="image-20240903212341404"></p><p>2、安装与配置<br>（1）下载之后，直接解压<br>（2）进入conf&#x2F;目录，找到application.properties文件，可以进行修改nacos服务的端口，以及可以配置数据库连接，进行数据持久化，如下图，其中数据库名称需要与后面对应</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/image-20240903212627033.png" alt="image-20240903212627033"></p><p>（3）创建一个名为<code>nacos</code>的数据库，在该数据库执行安装目录<code>conf/</code>下的<code>mysql-schema.sql</code>文件对数据库进行初始化，初始化后的表如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/image-20240903212854692.png" alt="image-20240903212854692"></p><p>（4）配置登录用户名和密码，执行以下sql语句插入登录用户信息，插入后的用户名和密码均为<code>nacos</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, PASSWORD, enabled) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="hljs-literal">TRUE</span>);<br> <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> roles (username, role) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;ROLE_ADMIN&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（5）配置鉴权，编辑文件<code>conf/application.properties</code>，其中将<code>nacos.core.auth.enabled</code>设为<code>true</code>，<code>nacos.core.auth.plugin.nacos.token.secret.key</code>是用于生成JWT令牌的<code>SecretKey</code>，可以使用随机字符生成器进行生成，长度不可低于32位，另外<code>nacos.core.auth.server.identity.key</code>和<code>nacos.core.auth.server.identity.value</code>不能为空，可以自定义内容，如下图。</p><p>随机字符生成器：<a href="http://tool.pfan.cn/random">随机字符串生成 - 程序员工具箱 - 在线工具 (pfan.cn)</a></p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/image-20240903213143481.png" alt="image-20240903213143481"></p><p>3、启动Nacos</p><p>随后进入到安装目录的<code>bin/</code>目录下，使用命令<code>.\startup.cmd -m standalone</code>以<code>standalone</code>方式启动Nacos，出现以下提示即为启动成功</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/image-20240903230215550.png" alt="image-20240903230215550"></p><p>之后进入Console后的地址即可使用用户名和密码<code>nacos</code>进行登录</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/image-20240903230304210.png" alt="image-20240903230304210"></p>]]></content>
    
    
    <categories>
      
      <category>仿斗鱼项目知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”もらいます”和”くれます”的区别</title>
    <link href="/2024/09/02/%E5%8D%9A%E5%AE%A2-2024-09-02-14-02-02/"/>
    <url>/2024/09/02/%E5%8D%9A%E5%AE%A2-2024-09-02-14-02-02/</url>
    
    <content type="html"><![CDATA[<p>“もらいます”和“くれます”在日语中都是表示“给予”或“接受”的动词，但它们的使用方式和含义略有不同。</p><h3 id="もらいます（貰います）"><a href="#もらいます（貰います）" class="headerlink" title="もらいます（貰います）"></a>もらいます（貰います）</h3><ul><li><strong>含义</strong>：表示“（我&#x2F;我们&#x2F;某人）从别人那里接受&#x2F;得到某物”。</li><li><strong>视角</strong>：从接受者的角度出发。</li><li>例句：<ul><li>友達からプレゼントを<strong>もらいました</strong>。<br>（从朋友那里<strong>收到了</strong>礼物。）</li></ul></li></ul><h3 id="くれます（呉れます）"><a href="#くれます（呉れます）" class="headerlink" title="くれます（呉れます）"></a>くれます（呉れます）</h3><ul><li><strong>含义</strong>：表示“某人给予我&#x2F;我们某物”。</li><li><strong>视角</strong>：从给予者的角度出发，但该动作是对说话人（或说话人相关的人）有利的。</li><li>例句：<ul><li>友達が私にプレゼントを<strong>くれました</strong>。<br>（朋友<strong>给了</strong>我一份礼物。）</li></ul></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>主语的不同：<ul><li>“もらいます”的主语是接受者（通常是“我”或“我们”）。</li><li>“くれます”的主语是给予者。</li></ul></li><li>使用场景的不同：<ul><li>当想表达“我从别人那里得到了什么”时，用“もらいます”。</li><li>当想表达“某人给了我什么”时，用“くれます”。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果关注的是<strong>接受</strong>，用“もらいます”。</li><li>如果关注的是<strong>给予</strong>，并且这个给予对你（或你关心的人）有利，用“くれます”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>N4</tag>
      
      <tag>授受动词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ安装过程问题记录</title>
    <link href="/2024/08/30/%E5%8D%9A%E5%AE%A2-2024-08-30-23-26-00/"/>
    <url>/2024/08/30/%E5%8D%9A%E5%AE%A2-2024-08-30-23-26-00/</url>
    
    <content type="html"><![CDATA[<p>安装环境为MacOS 12.7.5</p><ol><li><p>在启动NameServer时报错，<code>RROR: Please set the JAVA_HOME variable in your environment, We need java(x64)! !!</code></p><p>解决方法：配置JAVA_HOME，需要配置1.8的JDK，高于这个版本将报另一个错误<code>macos rocketmq Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.</code></p></li><li><p>在启动Broker时报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Error: VM option &#x27;UseG1GC&#x27; is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.<br>Error: Could not create the Java Virtual Machine.<br>Error: A fatal exception has occurred. Program will exit.<br></code></pre></td></tr></table></figure><p>解决方法：这个错误表示在启动 RocketMQ 的时候，JVM 尝试使用 <code>UseG1GC</code> 这个垃圾收集器选项，但它被标记为实验性的，因此需要显式地解锁实验性选项才能使用。</p><p>可以通过以下步骤来解决这个问题：</p><ol><li><p>找到 RocketMQ 的启动脚本，这通常在 <code>bin</code> 目录下，例如 <code>runbroker.sh</code>（Linux&#x2F;macOS）或者 <code>runbroker.cmd</code>（Windows）。</p></li><li><p>编辑这个启动脚本，找到 JVM 参数的部分。你可能会看到类似 <code>JAVA_OPT</code> 的变量，用来配置 JVM 启动参数。</p></li><li><p>在 <code>JAVA_OPT</code> 变量中添加 <code>-XX:+UnlockExperimentalVMOptions</code>，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">JAVA_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -XX:+UnlockExperimentalVMOptions&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>保存并关闭文件，然后重新启动 RocketMQ。</p></li></ol><p>如果不确定如何修改，下面是一个示例，如果在 <code>runbroker.sh</code> 中看到以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">JAVA_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2g -XX:+UseG1GC&quot;</span><br></code></pre></td></tr></table></figure><p>可以修改为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">JAVA_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2g -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC&quot;</span><br></code></pre></td></tr></table></figure><p>这样，启动时就不会再报这个错误了。</p></li><li><p>启动消费者或生成者时报错</p><p>其中有一条报错信息为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Caused by: io.netty.handler.codec.EncoderException: java.lang.NoSuchMethodError: java.nio.ByteBuffer.flip()Ljava/nio/ByteBuffer;<br></code></pre></td></tr></table></figure><p>__问题原因：__这个报错的原因是因为，在我一开始安装RocketMQ时，使用的方式是自行用mvn对源码进行编译的方式，因为当时编译时使用的JDK版本为17，但是后面运行时使用为JDK1.8，倒是ByteBuffer.flip()的实现方式不同造成了这个错误。</p><p>__解决方法：__在编译RocketMQ时使用JDK1.8</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>仿斗鱼项目知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Knife4j快速使用</title>
    <link href="/2024/08/24/%E5%8D%9A%E5%AE%A2-2024-08-24-21-33-58/"/>
    <url>/2024/08/24/%E5%8D%9A%E5%AE%A2-2024-08-24-21-33-58/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Knife4j是一个用于生成和展示API文档的工具，同时它还提供了在线调试的功能。</p><p><strong>了解</strong>：</p><ul><li>Knife4j有多个版本，最新版的Knife4j基于开源项目<code>springdoc-openapi</code>，这个开源项目的核心功能就是根据SpringBoot项目中的代码自动生成符合OpenAPI规范的接口信息。</li><li>OpenAPI规范定义接口文档的内容和格式，其前身是<code>Swagger</code>规范。</li></ul><h3 id="与SpringBoot集成"><a href="#与SpringBoot集成" class="headerlink" title="与SpringBoot集成"></a>与SpringBoot集成</h3><p>与SpringBoot的集成相对简单，具体操作如下</p><ol><li><p><strong>创建SpringBoot项目</strong></p></li><li><p><strong>引入Maven 依赖</strong></p><p>Knife4j的依赖如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建配置类</strong></p><p>创建<code>Knife4jConfiguration</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife4jConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">openAPI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span>()<br>                .info(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>()<br>                        .title(<span class="hljs-string">&quot;hello-knife4j项目API&quot;</span>)<br>                        .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                        .description(<span class="hljs-string">&quot;hello-knife4j项目的接口文档&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> GroupedOpenApi <span class="hljs-title function_">userAPI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> GroupedOpenApi.builder().group(<span class="hljs-string">&quot;用户信息管理&quot;</span>).<br>                pathsToMatch(<span class="hljs-string">&quot;/user/**&quot;</span>).<br>                build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> GroupedOpenApi <span class="hljs-title function_">systemAPI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> GroupedOpenApi.builder().group(<span class="hljs-string">&quot;产品信息管理&quot;</span>).<br>                pathsToMatch(<span class="hljs-string">&quot;/product/**&quot;</span>).<br>                build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>启动项目</strong></p><p>启动SpringBoot项目，访问<a href="http://localhost:8080/doc.html%EF%BC%8C%E8%A7%82%E5%AF%9F%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E3%80%82">http://localhost:8080/doc.html，观察接口文档。</a></p></li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Knife4j的使用也十分简单，我们只需使用几个简单注解，对接口进行描述，Knife4j就能自动生成API文档了。具体操作如下</p><ol><li><p><strong>描述实体类</strong></p><p>创建<code>com.atguigu.helloknife4j.entity.User</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Schema(description = &quot;用户信息实体&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-meta">@Schema(description = &quot;编号&quot;)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-meta">@Schema(description = &quot;用户姓名&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Schema(description = &quot;用户年龄&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@Schema(description = &quot;用户邮箱&quot;)</span><br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点</strong>：</p><p><code>@Schema</code>注解用于描述作为接口参数或者返回值的实体类的数据结构。</p></li><li><p><strong>描述Controller接口</strong></p><p>创建<code>HelloController</code>，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Tag(name = &quot;用户信息管理&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@Operation(summary = &quot;根据id获取用户信息&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;getById&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@Parameter(description = &quot;用户id&quot;)</span> <span class="hljs-meta">@RequestParam</span> Long id)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(id);<br>        user.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        user.setAge(<span class="hljs-number">11</span>);<br>        user.setEmail(<span class="hljs-string">&quot;zhangsan@email.com&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点</strong>：</p><p><code>@Tag</code>注解用于对接口进行分类，相同<code>Tag</code>的接口会放在同一个菜单。</p><p><code>@Operation</code>用于对接口进行描述。</p><p><code>@Parameter</code>用于对HTTP请求参数进行描述</p></li></ol><h3 id="参数打平"><a href="#参数打平" class="headerlink" title="参数打平"></a>参数打平</h3><p>默认情况下Knife4j为接口生成的接口文档中实体参数字段糅合在一起，不方便调试，可在application.yml文件中增加如下配置，将参数做打平处理</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">springdoc:</span><br>  <span class="hljs-attr">default-flat-param-object:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>尚庭公寓后端项目知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Knife4j</tag>
      
      <tag>SpingBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Data Redis快速入门</title>
    <link href="/2024/08/24/%E5%8D%9A%E5%AE%A2-2024-08-24-21-13-42/"/>
    <url>/2024/08/24/%E5%8D%9A%E5%AE%A2-2024-08-24-21-13-42/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis常用数据类型及命令"><a href="#Redis常用数据类型及命令" class="headerlink" title="Redis常用数据类型及命令"></a>Redis常用数据类型及命令</h2><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><p><strong>查看所有键</strong></p><p><code>keys</code>命令可用于查看所有键，语法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keys pattern<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：pattern用于匹配key，其中<code>*</code>表示任意个任意字符，<code>?</code>表示一个任意字符。</p><p>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; KEYS *<br><span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;k3&quot;</span><br><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;k1&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：该命令会遍历Redis服务器中保存的所有键，因此当键很多时会影响整个Redis服务的性能，线上环境需要谨慎使用。</p></li><li><p><strong>键总数</strong></p><p><code>dbsize</code>可用于查看键的总数，语法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dbsize<br></code></pre></td></tr></table></figure></li><li><p><strong>判断键是否存在</strong></p><p><code>exists</code>命令可用于判断一个键是否存在，语法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exists key<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：若键存在则返回1，不存在则返回0。</p></li><li><p><strong>删除键</strong></p><p><code>del</code>可用于删除指定键，语法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">del key [key ...]<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：返回值为删除键的个数，若删除一个不存在的键，则返回0。</p></li><li><p><strong>查询键的剩余过期时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ttl key<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<code>ttl</code>的含义为<strong>time to live</strong>，用于查询一个定时键的剩余存活时间，返回值以秒为单位。若查询的键的未设置过期时间，则返回<code>-1</code>，若查询的键不存在，则返回<code>-2</code>。</p></li><li><p><strong>数据库管理命令</strong></p><p>Redis默认有编号为0~15的16个逻辑数据库，每个数据库之间的数据是相互独立的，所有连接默认使用的都是0号数据库。</p><ul><li><p><strong>切换数据库</strong></p><p><code>select</code>命令可用于切换数据库，语法如下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">index</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：若index超出范围，会报错</p></li><li><p><strong>清空数据库</strong></p><p><code>flushdb</code>命令会清空当前所选用的数据库，<code>flushall</code>命令会清空0~15号所有的数据库。</p><p><strong>注意</strong>：生产环境慎用</p></li></ul></li></ul><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><ol><li><p><strong>概述</strong></p><p>Redis中的string类型保存的是字节序列（Sequence of bytes），因此任意类型的数据，只要经过序列化之后都可以保存到Redis的string类型中，包括文本、数字甚至是一个对象。</p></li><li><p><strong>常用命令</strong></p><ul><li><p><strong>set</strong></p><p><code>set</code>命令用于添加string类型的键值对，具体语法如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">SET key value [NX|<span class="hljs-type">XX</span>] [EX seconds|<span class="hljs-type">PX</span> milliseconds]<br></code></pre></td></tr></table></figure><p>各选项含义如下</p><ul><li>NX：仅在key不存在时set</li><li>XX：仅在key存在时set</li><li>EX seconds：设置过期时间，单位为秒</li><li>PX milliseconds：设置过期时间，单位为毫秒</li></ul></li><li><p><strong>get</strong></p><p><code>get</code>命令用于获取某个string类型的键对应的值，具体语法如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> key<br></code></pre></td></tr></table></figure></li><li><p><strong>incr</strong></p><p><code>incr</code>命令用于对数值做自增操作，具体语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">INCR key</span><br></code></pre></td></tr></table></figure><p>若key对应的value是整数，则返回自增后的结果，若不是整数则报错，若key不存在则创建并返回1。</p></li><li><p><strong>decr</strong></p><p><code>decr</code>命令用于对数值做自减操作，具体语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DECR key</span><br></code></pre></td></tr></table></figure><p>若key对应的value是整数，则返回自减后的结果，若不是整数则报错，若key不存在则创建并返回-1。</p></li></ul></li><li><p><strong>应用场景</strong></p><p>string类型常用于缓存、计数器等场景。</p></li></ol><h3 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h3><ol><li><p><strong>概述</strong></p><p>list类型可用于存储多个string类型的元素，并且所有元素按照被添加的顺序存储。</p></li><li><p><strong>常用命令</strong></p><p>list类型相关的命令较多，下面分类进行进行介绍。</p><ul><li><p><strong>添加元素</strong></p><p>向列表中添加元素的命令有<code>lpush</code>、<code>rpush</code> 、<code>linsert</code>，各命令的功能与用法如下</p><ul><li><p><code>lpush</code></p><p>该命令用于向list左侧添加元素，语法如下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">lpush<span class="hljs-built_in"> key</span> <span class="hljs-keyword">element</span> [<span class="hljs-keyword">element</span> ...]<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">lpush l1 <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br></code></pre></td></tr></table></figure></li><li><p><code>rpush</code></p><p>该命令用于向list右侧添加元素，语法如下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">rpush<span class="hljs-built_in"> key</span> <span class="hljs-keyword">element</span> [<span class="hljs-keyword">element</span> ...]<br></code></pre></td></tr></table></figure></li><li><p><code>linsert</code></p><p>该命令用于向list指定位置添加元素，语法如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">linsert</span> key before|<span class="hljs-keyword">after</span> pivot element<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">linsert</span> l1 <span class="hljs-keyword">after</span> b new<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>查询元素</strong></p><p>查询list元素的命令有<code>lindex</code>和<code>lrange</code>，各命令的功能与用法如下</p><ul><li><p><code>lindex</code></p><p>该命令用于获取指定索引位置的元素，语法如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lindex</span> key index<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：index从左到右依次是0，1，2…，从右到左依次是-1，-2，-3…</p></li><li><p><code>lrange</code></p><p>该命令用于获取指定范围内的元素列表，语法如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lrange</span> key start stop<br></code></pre></td></tr></table></figure><p>示例</p><p>获取list全部元素，命令如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lrange</span> l1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>删除元素</strong></p><p>删除list元素的命令有<code>lpop</code>、<code>rpop</code>、<code>lrem</code>，各命令的功能与用法如下</p><ul><li><p><code>lpop</code></p><p>该命令用于移除并返回list左侧元素，语法如下</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">lpop <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：count参数表示移除元素的个数</p></li><li><p><code>rpop</code></p><p>该命令用于移除并返回list右侧的元素，语法如下</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">rpop <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br></code></pre></td></tr></table></figure></li><li><p><code>lrem</code></p><p>该命令用于移除list中的指定元素，语法如下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">lrem<span class="hljs-built_in"> key</span><span class="hljs-built_in"> count</span> <span class="hljs-keyword">element</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：count参数表示要移除element元素的个数（list中可以存在多个相同的元素），count的用法如下</p><ul><li>若count&gt;0，则从左到右删除最多count个element元素</li><li>若count&lt;0，则从右到左删除最多count（的绝对值）个element元素</li><li>若count&#x3D;0，则删除所有的element元素</li></ul></li></ul></li><li><p><strong>修改元素</strong></p><p><code>lset</code>命令可用于修改指定索引位置的元素，语法如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lset</span> key index element<br></code></pre></td></tr></table></figure></li><li><p><strong>其他</strong></p><p><code>llen</code>命令可用于查看list长度，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">llen key</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>应用场景</strong></p><ul><li>社交应用中，可使用list缓存每个用户发布的最新的N条记录。</li><li>list可用作异步消息队列。</li></ul></li></ol><h3 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h3><ol><li><p><strong>概述</strong></p><p>和list类型相似，set类型也可用来存储多个string类型的元素，但与list类型不同，set中的元素是无序的，且set中不会包含相同元素。</p></li><li><p><strong>常用命令</strong></p><ul><li><p><strong>集合内</strong></p><ul><li><p><strong>sadd</strong></p><p>该命令用于向set中添加元素，语法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sadd key member [member ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>smembers</strong></p><p>该命令用于查询set中的全部元素，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">smembers key</span><br></code></pre></td></tr></table></figure></li><li><p><strong>srem</strong></p><p>该命令用于移除set中的指定元素，语法如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">srem <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>spop</strong></p><p>该命令随机移除并返回set中的n个元素，语法如下</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">spop <span class="hljs-built_in">key</span> [<span class="hljs-built_in">count</span>]<br></code></pre></td></tr></table></figure></li><li><p><strong>srandmember</strong></p><p>该命令随机返回set中的n个元素（不删除），语法如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">srandmember </span>key [<span class="hljs-built_in">count</span>]<br></code></pre></td></tr></table></figure></li><li><p><strong>scard</strong>（Cardinality，基数）</p><p>该命令用于查询set中的元素个数，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scard key</span><br></code></pre></td></tr></table></figure></li><li><p><strong>sismember</strong></p><p>该命令用于元素是否在set中，语法如下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">sismember<span class="hljs-built_in"> key</span> <span class="hljs-keyword">element</span><br></code></pre></td></tr></table></figure></li><li><p><strong>集合间</strong></p><ul><li><p><strong>sinter</strong></p><p>该命令用于计算多个集合的交集，语法如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sinter <span class="hljs-built_in">key</span> [<span class="hljs-built_in">key</span> ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>sunion</strong></p><p>该命令用于计算多个集合的并集，语法如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sunion <span class="hljs-built_in">key</span> [<span class="hljs-built_in">key</span> ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>sdiff</strong></p><p>该命令用于计算多个集合的差集，语法如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sdiff <span class="hljs-built_in">key</span> [<span class="hljs-built_in">key</span> ...]<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><strong>应用场景</strong></p><p>set可用于计算共同关注好友，随机抽奖系统等等。</p></li></ol><h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><ol><li><p><strong>概述</strong></p><p>hash类型类似于Java语言中的<code>HashMap</code>，可用于存储键值对。</p></li><li><p><strong>常用命令</strong></p><ul><li><p><strong>hset</strong></p><p>该命令用于向hash中增加键值对，语法如下</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hset</span> key <span class="hljs-meta">field</span> value [<span class="hljs-meta">field</span> value ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>hget</strong></p><p>该命令用于获取hash中某个键对应的值，语法如下</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hget</span> key <span class="hljs-meta">field</span><br></code></pre></td></tr></table></figure></li><li><p><strong>hdel</strong></p><p>该命令用于删除hash中的指定的键值对，语法如下</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hdel</span> key <span class="hljs-meta">field</span> [<span class="hljs-meta">field</span> ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>hlen</strong></p><p>该命令用于查询hash中的键值对个数，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hlen key</span><br></code></pre></td></tr></table></figure></li><li><p><strong>hexists</strong></p><p>该命令用于判断hash中的某个键是否存在，语法如下</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hexists</span> key <span class="hljs-meta">field</span><br></code></pre></td></tr></table></figure></li><li><p><strong>hkeys</strong></p><p>该命令用于返回hash中所有的键，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hkeys key</span><br></code></pre></td></tr></table></figure></li><li><p><strong>hvals</strong></p><p>该命令用于返回hash中所有的值，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hvals key</span><br></code></pre></td></tr></table></figure></li><li><p><strong>hgetall</strong></p><p>该命令用于返回hash中所有的键与值，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hgetall key</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>应用场景</strong></p><p>hash类型可用于缓存对象等。</p></li></ol><h3 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h3><ol><li><p><strong>概述</strong></p><p>zset（sorted set）被称为有序集合，同set相似，zset中也不会包含相同元素，但不同的是，zset中的元素是有序的。并且zset中的元素并非像list一样按照元素的插入顺序排序，而是按照每个元素的分数（score）排序。</p></li><li><p><strong>常用命令</strong></p><ul><li><p><strong>zadd</strong></p><p>该命令用于向zset中添加元素，语法如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">ZADD <span class="hljs-built_in">key</span> [NX|XX] score <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>NX：仅当member不存在时才add</li><li>XX：仅当member存在时才add</li></ul></li><li><p><strong>zcard</strong></p><p>该命令用于计算zset中的元素个数，语法如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">zcard key</span><br></code></pre></td></tr></table></figure></li><li><p><strong>zscore</strong></p><p>改名用于查看某个元素的分数，语法如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure></li><li><p><strong>zrank&#x2F;zrevrank</strong></p><p>这组命令用于计算元素的排名，其中zrank按照score的升序排序，zrevrank则按照降序排序，语法如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zrank/zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong>名次从0开始。</p></li><li><p><strong>zrem</strong></p><p>该命令用于删除元素，语法如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zrem <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li><li><p><strong>zincrby</strong> </p><p>该命令用于增加元素的分数，语法如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure></li><li><p><strong>zrange</strong></p><p>该命令用于查询指定区间范围的元素，语法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">zrange key start <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[byscore]</span> <span class="hljs-selector-attr">[rev]</span> <span class="hljs-selector-attr">[limit offset count]</span> <span class="hljs-selector-attr">[withscores]</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>start&#x2F;stop：用于指定查询区间，但是在不同模式下，其代表的含义也不相同<ul><li>默认模式下，<code>start~stop</code>表示的是名次区间，且该区间为闭区间。名次从0开始，且可为负数，-1表示倒数第一，-2表示倒数第二，以此类推。</li><li>byscore模式下（声明了byscore参数），则<code>start~stop</code>表示的就是分数区间，该区间默认仍为闭区间。在该模式下，可以在<code>start</code>或<code>stop</code>前增加<code>(</code>来表示开区间，例如<code>(1 (5</code>，表示的就是<code>(1,5)</code>这个开区间。除此之外，还可以使用<code>-inf</code>和<code>+inf</code>表示负无穷和正无穷。</li></ul></li><li>byscore：用于切换到分数模式</li><li>rev：表示降序排序。在byscore模式下使用rev参数需要注意查询区间，start应大于stop。</li><li>limit：该选项只用于byscore模式，作用和sql语句中的limit一致</li><li>withscores：用于打印分数</li></ul></li></ul></li><li><p><strong>应用场景</strong></p><p>zset主要用于各种排行榜。</p></li></ol><h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><h3 id="Spring-Data-Redis概述"><a href="#Spring-Data-Redis概述" class="headerlink" title="Spring Data Redis概述"></a>Spring Data Redis概述</h3><p><strong>Spring Data Redis</strong> 是Spring大家族中的一个子项目，主要用于Spring程序和Redis的交互。它基于的Redis Java客户端（<a href="https://github.com/redis/jedis">Jedis</a>和<a href="https://lettuce.io/">Lettuce</a>）做了抽象，提供了一个统一的编程模型，使得Spring程序与Redis的交互变得十分简单。</p><p><strong>Spring Data Redis</strong> 中有一个十分重要的类——<code>RedisTemplate</code>，它封装了与Redis进行的交互的各种方法，我们主要用使用它与Redis进行交互。</p><h3 id="Spring-Data-Redis快速入门"><a href="#Spring-Data-Redis快速入门" class="headerlink" title="Spring Data Redis快速入门"></a>Spring Data Redis快速入门</h3><ol><li><p><strong>创建SpringBoot项目</strong></p></li><li><p><strong>引入Maven依赖</strong></p><p>Spring Boot提供了对Spring Data Redis的支持，在Spring Boot项目中可以直接引入<code>spring-boot-starter-data-redis</code>来完成Spring Data Redis的自动配置，具体依赖如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置application.yml文件</strong></p><p>在<code>application.yml</code>文件中增加如下参数，端口默认为<code>6379</code>，若没有密码，<code>password</code>字段可不写</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-string">xxx.xxx.xxx.xxx</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">xxxxxx</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>RedisTemplate使用</strong></p><p>由于<code>spring-boot-starter-data-redis</code>中提供了<code>RedisTemplate</code>的自动配置，所以我们可以将<code>RedisTemplate</code>注入自己的类中，如下边的案例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRedisTemplate</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisTemplate</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据Redis的数据类型，RedisTemplate对各种交互方法做了分组，以下是常用的几个分组</p><table><thead><tr><th align="left">分组</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>redisTemplate.opsForValue()</code></td><td align="left">操作string类型的方法</td></tr><tr><td align="left"><code>redisTemplate.opsForList()</code></td><td align="left">操作list类型的方法</td></tr><tr><td align="left"><code>redisTemplate.opsForSet()</code></td><td align="left">操作set类型的方法</td></tr><tr><td align="left"><code>redisTemplate.opsForHash()</code></td><td align="left">操作hash类型的方法</td></tr><tr><td align="left"><code>redisTemplate.opsForZSet()</code></td><td align="left">操作zset类型的方法</td></tr><tr><td align="left"><code>redisTemplate</code></td><td align="left">通用方法</td></tr></tbody></table><p>下面简单测试几个简单的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRedisTemplate</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;key1&quot;</span>);<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDel</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.delete(<span class="hljs-string">&quot;key1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>序列化问题</strong></p><ul><li><p><strong>问题演示</strong></p><ul><li><p><strong>问题一</strong></p><p>使用RedisTemplate向Redis中增加一个键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key2&quot;</span>,<span class="hljs-string">&quot;value2&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用RedisTemplate查询key2所对应的value，有结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">redisTemplate.opsForValue().get(<span class="hljs-string">&quot;key2&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用命令行客户端查询key2所对应的value，无结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> key2<br></code></pre></td></tr></table></figure></li><li><p><strong>问题二</strong></p><p>在图形化客户端或者命令行客户端观察key2，显示异常</p></li></ul></li><li><p><strong>问题说明</strong></p><p>上述问题的根本原因是，Redis中的key和value均是以二进制的形式存储的，因此客户端输入的key和value都会经过序列化之后才发往Redis服务端。而RedisTemplate所使用序列化方式和命令行客户端采用序列化方式不相同，进而导致序列化之后的二进制数据不同，所以才会导致上述的现象。</p></li></ul></li><li><p><strong>StringRedisTemplate使用</strong></p><p>为解决上述问题，可使用<code>StringRedisTemplate</code>代替<code>RedisTemplate</code>，因为<code>StringRedisTemplate</code>使用的序列化器和命令行所使用的序列化器是相同的。</p><p><code>spring-boot-starter-data-redis</code>同样提供了<code>StringRedisTemplate</code>的自动配置，因此我们也可以直接将其注入到自己的类中。实例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStringRedisTemplate</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;key4&quot;</span>);<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDel</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.delete(<span class="hljs-string">&quot;key4&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>尚庭公寓后端项目知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客-Fluid主题-Waline评论系统-Vercel免费部署</title>
    <link href="/2024/08/24/%E5%8D%9A%E5%AE%A2-2024-08-24-00-22-58/"/>
    <url>/2024/08/24/%E5%8D%9A%E5%AE%A2-2024-08-24-00-22-58/</url>
    
    <content type="html"><![CDATA[<p>这次的部署过程的环境是在Hexo的Fluid主题上进行的，其他主题大同小异。</p><h2 id="LeanCloud设置（数据库）"><a href="#LeanCloud设置（数据库）" class="headerlink" title="LeanCloud设置（数据库）"></a>LeanCloud设置（数据库）</h2><ol><li><p><a href="https://console.leancloud.app/login">登录</a> 或 <a href="https://console.leancloud.app/register">注册</a> <code>LeanCloud 国际版</code> 并进入 <a href="https://console.leancloud.app/apps">控制台</a></p></li><li><p>点击左上角 <a href="https://console.leancloud.app/apps">创建应用</a> 并起一个你喜欢的名字 (请选择免费的开发版):</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/leancloud-1-CucZPnJ0.png" alt="创建应用"></p></li><li><p>进入应用，选择左下角的 <code>设置</code> &gt; <code>应用 Key</code>。你可以看到你的 <code>APP ID</code>,<code>APP Key</code> 和 <code>Master Key</code>。请记录它们，以便后续使用。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/leancloud-2-C9bCeSu_.png" alt="ID 和 Key"></p></li></ol><div class="note note-warning">            <p><strong>PS:</strong> LeanCloud国内版需要完成备案接入，建议使用国际版！</p>          </div><p>如果你正在使用 Leancloud 国内版 (<a href="https://leancloud.cn/">leancloud.cn</a>)，我们推荐你切换到国际版 (<a href="https://leancloud.app/">leancloud.app</a>)。否则，你需要为应用额外绑定<strong>已备案</strong>的域名，同时购买独立 IP 并完成备案接入:</p><ul><li>登录国内版并进入需要使用的应用</li><li>选择 <code>设置</code> &gt; <code>域名绑定</code> &gt; <code>API 访问域名</code> &gt; <code>绑定新域名</code> &gt; 输入域名 &gt; <code>确定</code>。</li><li>按照页面上的提示按要求在 DNS 上完成 CNAME 解析。</li><li>购买独立 IP 并提交工单完成备案接入。(独立 IP 目前价格为 ￥ 50&#x2F;个&#x2F;月)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/leancloud-3-CT_lZM0A.png" alt="域名设置"></p><h2 id="Vercel部署（服务端）"><a href="#Vercel部署（服务端）" class="headerlink" title="Vercel部署（服务端）"></a>Vercel部署（服务端）</h2><p><a href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example"><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/20240824210708-20240824210803353-20240824210940996.png" alt="Vercel"></a></p><ol><li><p>点击上方按钮，跳转至 Vercel 进行 Server 端部署。</p><div class="note note-primary">            <p>如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</p>          </div></li><li><p>输入一个你喜欢的 Vercel 项目名称并点击 <code>Create</code> 继续:</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-1-DoAtoGHg.png" alt="创建项目"></p></li><li><p>此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-3-Brb_j0cD.png" alt="deploy">一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 <code>Go to Dashboard</code> 可以跳转到应用的控制台。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-4-CNMnhm70.png" alt="deploy"></p></li><li><p>点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量 <code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 LeanCloud 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-5-CIj2EZQq.png" alt="设置环境变量"></p><div class="note note-warning">            <p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p>          </div></li><li><p>环境变量配置完成之后点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-6-CQnJ4Agt.png" alt="redeploy"></p></li><li><p>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。</p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-7-DbSum90d-20240824205628939.png" alt="redeploy success"></p></li></ol><h2 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h2><div class="note note-danger">            <p>如果你的博客是使用了自己的域名，这一项必须进行绑定配置，否则评论时会出现跨域问题</p>          </div><ol><li><p>点击顶部的 <code>Settings</code> - <code>Domains</code> 进入域名配置页</p></li><li><p>输入需要绑定的域名并点击 <code>Add</code></p><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-8-BDTeHH3e.png" alt="Add domain"></p></li><li><p>在域名服务器商处添加新的 <code>CNAME</code> 解析记录</p><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>CNAME</td><td>example</td><td>cname.vercel-dns.com</td></tr></tbody></table></li><li><p>等待生效，你可以通过自己的域名来访问了🎉</p><ul><li>评论系统：example.yourdomain.com</li><li>评论管理：example.yourdomain.com&#x2F;ui</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cansoking/blog-pictures@master/vercel-9-Df5XGWYy.png" alt="success"></p></li></ol><h2 id="配置Fluid"><a href="#配置Fluid" class="headerlink" title="配置Fluid"></a>配置Fluid</h2><p>在<code>_config.fluid.yml</code>中配置评论为<code>Waline</code>，参数参考如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>  <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">waline</span><br></code></pre></td></tr></table></figure><p><code>Waline</code>的具体配置信息如下，其中<code>serverURL</code>的值为上一步中配置的子域名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Waline</span><br><span class="hljs-comment"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class="hljs-comment"># Derived from Valine, with self-hosted service and new features</span><br><span class="hljs-comment"># See: https://waline.js.org/</span><br><span class="hljs-attr">waline:</span><br>  <span class="hljs-attr">serverURL:</span> <span class="hljs-string">&#x27;https://example.archiewang.site/&#x27;</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredMeta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>]<br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">emoji:</span> [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class="hljs-attr">dark:</span> <span class="hljs-string">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class="hljs-attr">wordLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>至此结束部署，重新部署Hexo即可生效</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Waline</tag>
      
      <tag>Vercel</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus分页插件使用</title>
    <link href="/2024/08/23/%E5%8D%9A%E5%AE%A2-2024-08-23-11-46-05/"/>
    <url>/2024/08/23/%E5%8D%9A%E5%AE%A2-2024-08-23-11-46-05/</url>
    
    <content type="html"><![CDATA[<h4 id="配置分页"><a href="#配置分页" class="headerlink" title="配置分页"></a>配置分页</h4><p>创建配置类<code>MPConfiguration</code>，类名随意，第6行中需要传入数据库类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MPConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分页插件使用"><a href="#分页插件使用" class="headerlink" title="分页插件使用"></a>分页插件使用</h4><ul><li><p>构造分页对象</p><p>分页对象包含了分页的各项信息，其核心属性如下：</p><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>records</td><td>List</td><td>emptyList</td><td>查询数据列表</td></tr><tr><td>total</td><td>Long</td><td>0</td><td>查询列表总记录数</td></tr><tr><td>size</td><td>Long</td><td>10</td><td>每页显示条数，默认<code>10</code></td></tr><tr><td>current</td><td>Long</td><td>1</td><td>当前页</td></tr></tbody></table><p>分页对象既作为分页查询的参数，也作为分页查询的返回结果，当作为查询参数时，通常只需提供<code>current</code>和<code>size</code>属性，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IPage&lt;T&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, size);<br></code></pre></td></tr></table></figure><p>注：<code>IPage</code>为分页接口，<code>Page</code>为<code>IPage</code>接口的一个实现类。</p></li><li><p>分页查询</p><p>Mybatis Plus的<code>BaseMapper</code>和<code>ServiceImpl</code>均提供了常用的分页查询的方法，例如：</p><ul><li><p><code>BaseMapper</code>的分页查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IPage&lt;T&gt; <span class="hljs-title function_">selectPage</span><span class="hljs-params">(IPage&lt;T&gt; page,Wrapper&lt;T&gt; queryWrapper)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>ServiceImpl</code>的分页查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无条件分页查询</span><br>IPage&lt;T&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(IPage&lt;T&gt; page)</span>;<br><span class="hljs-comment">// 条件分页查询</span><br>IPage&lt;T&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;<br></code></pre></td></tr></table></figure></li><li><p>自定义Mapper</p><p>对于自定义SQL，也可以十分方便的完成分页查询，如下</p><p><code>Mapper</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IPage&lt;UserVo&gt; <span class="hljs-title function_">selectPageVo</span><span class="hljs-params">(IPage&lt;?&gt; page, Integer state)</span>;<br></code></pre></td></tr></table></figure><p><code>Mapper.xml</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectPageVo&quot;</span> resultType=<span class="hljs-string">&quot;xxx.xxx.xxx.UserVo&quot;</span>&gt;<br>    SELECT id,name FROM user WHERE state=#&#123;state&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>Mapper.xml</code>中的SQL只需实现查询<code>list</code>的逻辑即可，无需关注分页的逻辑。</p></li></ul></li><li><p>案例实操</p><p>分页查询案例如下：</p><p>创建<code>PageTest</code>测试类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-comment">//通用Service分页查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageService</span><span class="hljs-params">()</span> &#123;<br>        Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        Page&lt;User&gt; userPage = userService.page(page);<br>        userPage.getRecords().forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-comment">//通用Mapper分页查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageMapper</span><span class="hljs-params">()</span> &#123;<br>        IPage&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        IPage&lt;User&gt; userPage = userMapper.selectPage(page, <span class="hljs-literal">null</span>);<br>        userPage.getRecords().forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-comment">//自定义SQL分页查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCustomMapper</span><span class="hljs-params">()</span> &#123;<br>        IPage&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        IPage&lt;User&gt; userPage = userMapper.selectUserPage(page);<br>        userPage.getRecords().forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在UserMapper中声明分页查询方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IPage&lt;User&gt; <span class="hljs-title function_">selectUserPage</span><span class="hljs-params">(IPage&lt;User&gt; page)</span>;<br></code></pre></td></tr></table></figure><p>创建<code>resources/mapper/UserMapper.xml</code>文件，内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.hellomp.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserPage&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.hellomp.entity.User&quot;</span>&gt;</span><br>        select *<br>        from user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>Mybatis-Plus中<code>Mapper.xml</code>文件路径默认为：<code>classpath*:/mapper/**/*.xml</code>，可在<code>application.yml</code>中配置以下参数进行修改</p>   <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath*:/mapper/**/*.xml</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="MybatisX插件"><a href="#MybatisX插件" class="headerlink" title="MybatisX插件"></a>MybatisX插件</h4><p>MyBatis Plus提供了一个IDEA插件——<code>MybatisX</code>,使用它可根据数据库快速生成<code>Entity</code>、<code>Mapper</code>、<code>Mapper.xml</code>、<code>Service</code>、<code>ServiceImpl</code>等代码，使用户更专注于业务。</p><p>下面为具体用法</p><ol><li><p><strong>安装插件</strong></p><p>在IDEA插件市场搜索<code>MyBatisX</code>，进行在线安装</p></li><li><p><strong>配置数据库连接</strong></p><p>在IDEA中配置数据库连接</p></li><li><p><strong>生成代码</strong></p><p>配置实体类相关信息</p><p>配置代码模版信息</p><p>点击Finish然后查看生成的代码。</p></li></ol><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><ul><li><p><strong>xml文件<code>&lt;</code>和<code>&gt;</code>的转义</strong></p><p>由于xml文件中的<code>&lt;</code>和<code>&gt;</code>是特殊符号，需要转义处理。</p><table><thead><tr><th>原符号</th><th>转义符号</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td><code>&amp;lt;</code></td></tr><tr><td><code>&gt;</code></td><td><code>&amp;gt;</code></td></tr></tbody></table></li><li><p><strong>Mybatis-Plus分页插件注意事项</strong></p><p>使用Mybatis-Plus的分页插件进行分页查询时，如果结果需要使用<code>&lt;collection&gt;</code>进行映射，只能使用**<a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#nested-select-for-collection">嵌套查询（Nested Select for Collection）</a><strong>，而不能使用</strong><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#nested-results-for-collection">嵌套结果映射（Nested Results for Collection）</a>**。</p><p>即对于<code>&lt;collection&gt;</code>的内容使用单独一个sql进行查询。</p><p><strong>嵌套查询</strong>和<strong>嵌套结果映射</strong>是Collection映射的两种方式，下面通过一个案例进行介绍</p><p>例如有<code>room_info</code>和<code>graph_info</code>两张表，其关系为一对多</p><p>现需要查询房间列表及其图片信息，期望返回的结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">201</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;rent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;graphList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roomId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roomId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">202</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;rent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;graphList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roomId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roomId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>为得到上述结果，可使用以下两种方式</p><ul><li><p><strong>嵌套结果映射</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRoomPage&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;RoomPageMap&quot;</span>&gt;</span><br>    select ri.id room_id,<br>           ri.number,<br>           ri.rent,<br>       gi.id graph_id,<br>           gi.url,<br>           gi.room_id<br>    from room_info ri<br>   left join graph_info gi on ri.id=gi.room_id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;RoomPageMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;RoomInfoVo&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;room_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;graphInfoList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;GraphInfo&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;graph_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>嵌套查询</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRoomPage&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;RoomPageMap&quot;</span>&gt;</span><br>    select id,<br>           number,<br>           rent<br>    from room_info<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;RoomPageMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;RoomInfoVo&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;graphInfoList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;GraphInfo&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectGraphByRoomId&quot;</span>  <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectGraphByRoomId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;GraphInfo&quot;</span>&gt;</span><br>    select id,<br>           url,<br>       room_id<br>    from graph_info<br>    where room_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方法使用两个独立的查询语句来获取一对多关系的数据。首先，Mybatis会执行主查询来获取<code>room_info</code>列表，然后对于每个<code>room_info</code>，Mybatis都会执行一次子查询来获取其对应的<code>graph_info</code>。</p></li></ul><p>若现在使用MybatisPlus的分页插件进行分页查询，假如查询的内容是第<strong>1</strong>页，每页<strong>2</strong>条记录，显然<strong>嵌套结果映射</strong>的分页逻辑是存在问题的。</p></li><li><p>打印SQL语句</p><p>需要在<code>application.yml</code>文件中进行如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#用于打印框架生成的sql语句，便于调试</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>尚庭公寓后端项目知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo备份及博文模板配置</title>
    <link href="/2024/08/22/%E5%8D%9A%E5%AE%A2-2024-08-22-22-14-04/"/>
    <url>/2024/08/22/%E5%8D%9A%E5%AE%A2-2024-08-22-22-14-04/</url>
    
    <content type="html"><![CDATA[<p>为了防止误操作或意外情况导致的 Hexo 博客源文件丢失，或满足我们更换电脑进行写作的需求，所以需要进行备份。</p><h4 id="需要备份的文件和目录"><a href="#需要备份的文件和目录" class="headerlink" title="需要备份的文件和目录"></a>需要备份的文件和目录</h4><p>而在进行备份时，并不需要将整个博客目录全部备份，只需备份几个用户自定义的文件和配置</p><p><code>scaffolds</code> 文章的模板，需要备份</p><p><code>source</code> 文章和页面等源文件，需要备份</p><p><code>themes</code> 主题文件与配置，需要备份</p><p><code>_config.yml</code> 用户配置信息，需要备份</p><p><code>package.json</code> 模块列表，需要备份</p><h4 id="不需要备份的文件和目录"><a href="#不需要备份的文件和目录" class="headerlink" title="不需要备份的文件和目录"></a>不需要备份的文件和目录</h4><p><code>node_modules</code> 安装的模块，不用备份</p><p><code>public</code> 生成的文件静态网页文件，不用备份</p><p><code>db.json</code> 网页数据文件，编译生成静态网页时会自动更新，不用备份</p><p><code>package-lock.json</code> 依赖的模块安装记录，不用备份</p><p>此外如果主题目录下有<code>.git</code> 这个隐藏目录也可以删掉或者如下面所讲加入<code>.gitignore</code> 文件中在备份时忽略掉</p><h4 id="备份到-GitHub"><a href="#备份到-GitHub" class="headerlink" title="备份到 GitHub"></a>备份到 GitHub</h4><ol><li>在 GitHub 创建一个私密仓库 <code>hexo-source</code>，仓库名字随意，建议设置为私密仓库。</li><li>在你的站点目录下增加一个<code>.gitignore</code> 文件设置需要忽略的文件和目录，在其中添加不需要备份的内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs .gitignore">Text<br>node_modules/<br>public/<br>.deploy_git/<br>_config.landscape.yml<br>package-lock.json<br>db.json<br>themes/*/.git/<br>.DS_Store<br></code></pre></td></tr></table></figure><ol><li>备份你的站点源文件到仓库 <code>hexo-source</code>，其中<code>your_token</code>为你的GIthub访问Token，<code>username</code>为你的Github用户名</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git add *<br>git commit -m <span class="hljs-string">&quot;<span class="hljs-subst">$(date)</span>: Hexo backup&quot;</span><br>git remote add origin https://your_token@github.com/username/hexo-source.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><h4 id="恢复你的-Hexo-站点"><a href="#恢复你的-Hexo-站点" class="headerlink" title="恢复你的 Hexo 站点"></a>恢复你的 Hexo 站点</h4><ol><li>初始化一个 Hexo 站点。</li><li>从 GitHub 下载备份的内容到该 Hexo 站点目录下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://your_token@github.com/username/hexo-source.git<br></code></pre></td></tr></table></figure><ol><li>使用备份的 <code>package.json</code> 文件来恢复安装 Hexo 插件，使用 npm 进行安装：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>这将读取 <code>package.json</code> 文件中的依赖项列表，并下载并安装所需的插件和模块。</p><ol><li>生成静态网页并部署即可。</li></ol><h4 id="脚本化"><a href="#脚本化" class="headerlink" title="脚本化"></a>脚本化</h4><p>有了上面的基础，可以在站点目录下创建bash文件，用来简化操作</p><ol><li>文件<code>hexp_backup.sh</code>，用于备份Hexo源代码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-------------------------添加文件-------------------------&quot;</span><br>git add *<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------提交本地备份------------------------&quot;</span><br>git commit -m <span class="hljs-string">&quot;<span class="hljs-subst">$(date)</span>: Hexo backup&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------提交到远程仓库----------------------&quot;</span><br>git push -u origin main<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------备份源代码完成----------------------&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>文件<code>hexp_new_post.sh</code>，用于按照模板创建新博文</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">blog_name=<span class="hljs-string">&quot;博客-<span class="hljs-subst">$(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span>&quot;</span><br>hexo new <span class="hljs-string">&quot;<span class="hljs-variable">$blog_name</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------<span class="hljs-variable">$blog_name</span>.md 创建成功----------------------&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>文件<code>hexp_publish.sh</code>，用于编译部署站点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------清理本地缓存----------------------&quot;</span><br>hexo clean<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;------------------------开始部署------------------------&quot;</span><br>hexo d -g<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;------------------------部署结束------------------------&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>文件<code>hexp_publish_backup.sh</code>，用于整合部署和备份，通常写完博文后执行这个文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash hexo_publish.sh<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;------------------------开始备份源码-------------------------&quot;</span><br>bash hexo_backup.sh<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------全部部署流程完成----------------------&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;访问：http://archiewang.site&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
